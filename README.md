### 요구사항과 구현 내용
- 객체지향적인 코드로 계산기 구현하기
    - [x]  더하기
    - [x]  빼기
    - [x]  곱하기
    - [x]  나누기
    - [x]  우선순위(사칙연산)
- [x]  테스트 코드 구현하기
- [x]  계산 이력을 맵으로 데이터 저장기능 만들기
    - List로 저장
- 정규식은 사용하지 않았습니다.
- 괄호는 고려하지 않았습니다.

### 기능(Interface)

- CalculateService
    - 사용자의 입력을 전달받아 계산 및 저장.
    - 계산결과를 조회.

- Parser
    - 입력 문자열 유효성 검사.
    - 피연산자와 연산자를 스페이스 단위로 구분하여 새로운 문자열 반환

- Sorter
    - 연산자 우선순위, 인덱스 위치를 기준으로 정렬

- Calculate
    - 정렬 된 연산자를 기준으로 계산을 수행


### 실행 방법
``` bash
git clone https://github.com/Pawer0223/java-calculator.git;
cd java-calculator;

# mac
./gradlew build;
./graldew run;

# window
./gradlew.bat build;
./gradlew.bat run;
```

### PR 포인트 & 궁금한 점

1. 연산자 하드코딩 제거
* 문자열을 파싱, 우선순위 확인, 계산 과정에서 연산자를 하드코딩으로 비교하는 것을 제거하고자 Util 클래스에 static 필드로 `<Character, Operator에 대한 Enum>` 형식으로 데이터를 초기화 해서 참조하도록 구현하였습니다.
    * 이러한 경우 적용하면 더 효과적인 패턴? 전략? 이있을까요??

2. 문자열 파싱과정 역할의 분리
* 계산 가능한 수식을 확인하기 위해 최초 `유효성 검사, 출력을 위한 포맷으로 문자열 변환` 2가지 기능으로 분리하였으나 수식을 검증하는 룰이 변경 될 경우 변경사항이 2곳이 발생했습니다. 결과적으로 Parse라는 기능에서 유효성을 검사하면서 새로운 문자열을 만들도록 구현했습니다. 이 경우 단일 책임 원칙을 위배하는 것은 아닐까요? 더 적절한 방법은 무엇이 있을까요 ??

3. 코드에서 눈에 띄는 안좋은 습관이나, SOLID에 위배되는 경우, 개선 점에 대해 가감없이 조언주시면 달게받고 개선하겠습니다.
